export declare function deepCloneObj<T>(obj: T): T;
export declare function deepMerge<T extends Record<string, any>, U extends Record<string, any>>(target: T, source: U): T & U;
export declare function isEmpty<T extends object>(obj: T): boolean;
export declare function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K>;
export declare function omit<T, K extends keyof T>(obj: T, keys: K[]): Omit<T, K>;
export declare function flattenObject(obj: Record<string, any>, parentKey?: string, result?: Record<string, any>): Record<string, any>;
export declare function unflattenObject(obj: Record<string, any>): Record<string, any>;
export declare function invertObj<T extends Record<string, string | number | symbol>>(obj: T): Record<string, keyof T>;
export declare function hasKey(obj: Record<string, any>, key: string): boolean;
export declare function getNestedValue<T>(obj: Record<string, any>, path: string): Record<string, any>;
export declare function setNestedValue<T>(obj: Record<string, any>, path: string, value: T): boolean;
export declare function deleteKey<T>(obj: Record<string, T>, key: string): Record<string, T>;
export declare function deepEqual(obj1: any, obj2: any): boolean;
export declare function getDeepObjectSize(obj: Record<string, any>): number;
export declare function transformObjectKeys<T>(obj: Record<string, T>, transformFn: (key: string) => string): Record<string, T>;
export declare function transformObjectValues<T>(obj: Record<string, T>, transformFn: (value: T) => T): Record<string, T>;
export declare function objectToQueryString(obj: Record<string, any>): string;
export declare function queryStringToObject(queryString: string): Record<string, string>;
export declare function deepFreeze(obj: Record<string, any>): void;
export declare function seal(obj: Record<string, any>): void;
export declare function deepSeal(obj: Record<string, any>): void;
export declare function deepIsFrozen(obj: Record<string, any>): boolean;
export declare function deepIsSealed(obj: Record<string, any>): boolean;
export declare function hasDeepKey(obj: Record<string, any>, key: string): boolean;
export declare function isPlainObject(value: any): boolean;
export declare class TypeUtils {
    static isNumber(value: any): boolean;
    static isString(value: any): boolean;
    static isBoolean(value: any): boolean;
    static isObject(value: any): boolean;
    static isArray(value: any): boolean;
    static isFunction(value: any): boolean;
    static isNull(value: any): boolean;
    static isUndefined(value: any): boolean;
    static isSymbol(value: any): boolean;
    static isPlainObject(value: any): boolean;
    static isDate(value: any): boolean;
    static isRegExp(value: any): boolean;
    static isInstanceOf(value: any, constructor: Function): boolean;
    static getType(value: any): string;
}
export declare function isSubset<T>(obj1: Record<string, T>, obj2: Record<string, T>): boolean;
export declare function groupByKeys<T>(arr: T[], keys: (keyof T)[]): Record<string, T[]>;
export declare function arrayToObject<T extends Record<string, any>, K extends keyof T>(arr: T[], key: K): Record<string, T>;
export declare function getUniqueByKey<T extends Record<string, any>, K extends keyof T>(arr: T[], key: K): T[];
export declare function shallowCopy<T extends object>(obj: T): T;
export declare function intersectObjects<T extends Record<string, any>>(obj1: T, obj2: T): Partial<T>;
export declare function diffObjects<T extends Record<string, any>>(obj1: T, obj2: T): Partial<T>;
export declare function mapObjectValues<T, U>(obj: Record<string, T>, callback: (value: T, key: string, obj: Record<string, T>) => U): Record<string, U>;
